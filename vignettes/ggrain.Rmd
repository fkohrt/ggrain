---
title: "Raincloud vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Raincloud_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  #warning = FALSE, message = FALSE,
  comment = "#>"
)
```

```{r setup}
if (!require(pacman)) {
    install.packages("pacman")
}

pacman::p_load(ggplot2, rlang, grid, ggpp, lavaan, gghalves, patchwork, remotes, DT, ggsignif, reshape2)

remotes::install_github('njudd/ggrain')

library(ggrain)

```

## The `geom_rain()` function

* handles as many rainclouds as you wish and can overlap them by a group
* connects within-subject observations longitudinally with lines using `id.long.var` argument
* colors dots by a covariate using the `cov` argument
* handles likert data by adding y-jittering with `likert = TRUE`
* changes orientation with `+ coord_flip()`

All individual elements of the plots can be edited, these are split into aesthetic and positioning arguments that are supplied by lists. For example the boxplot's can be edited with `boxplot.args` and `boxplot.args.pos`, yet the others can also be edited by substituting for their name, i.e. `point/violin/line`. When you supply a list the defaults are overwritten so you may need to re-add them. To see the defaults run `?geom_rain`.

## Introduction 
```{r making dataset}

aging <- Demo.growth[,1:4]
aging$id <- as.factor(as.character(rep(1:dim(aging)[1])))
aging <- reshape2::melt(aging, id.vars = "id")
# aging$value_round <- round(aging$value,1)
colnames(aging)[2] <- "time"

aging$covariate <- -aging$value*2

aging$group <- c(rep("old", 200), rep("young", 200), rep("old", 200), rep("young", 200),
                 rep("old", 200), rep("young", 200), rep("old", 200), rep("young", 200))

aging$value[aging$group == "young"] <- aging$value[aging$group == "young"] + 1
aging$value[aging$group == "old" & aging$time == "t2"] <- aging$value[aging$group == "old" & aging$time == "t2"] -2
```

We will look at some aging data that has two groups (young and old) measured four times.

```{r showing datasets, eval=T}

DT::datatable(aging, rownames = F, class = 'cell-border stripe')
```

Here is our first plot that is just simply all the values in the aging data set. For the function to work the value you want to plot **must be given to the y argument** in ggplot. You can than flip the plot with `+ coord_flip()` as we demonstrate below.

```{r most basic raincloud possible}
ggplot(aging, aes(1, value)) +
  geom_rain() +
  theme_classic() +
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(), axis.ticks.x = element_blank())
```

Let's see what is happening over the four time points. The x value must be a factor or a character vector!

```{r rainclouds by time}

ggplot(aging, aes(time, value, fill = time)) +
  geom_rain(alpha = .5) +
  theme_classic() +
  scale_fill_brewer(palette = 'Dark2')
```

Let's color the dots by time, we do this by adding `color = time` to ggplot. The default behavior of `geom_boxplot` is to color the lines showing the median and IQR. Therefore, we need to add a `boxplot.args` for color to be black along with re-adding the default to show no outliers.

```{r rainclouds by time colored}

ggplot(aging, aes(time, value, fill = time, color = time)) +
  geom_rain(alpha = .3,
            boxplot.args = list(color = "black", outlier.shape = NA)) +
  theme_classic() +
  scale_fill_brewer(palette = 'Dark2') +
  scale_color_brewer(palette = 'Dark2')
```

We can flip the plots by adding `coord_flip()`

```{r rainclouds by time flip}
ggplot(aging, aes(time, value, fill = time)) +
  geom_rain(alpha = .5) +
  theme_classic() +
  scale_fill_brewer(palette = 'Dark2') +
  coord_flip()
```

This plot is a bit crammed, lets spread stuff out using the `boxplot.args.pos` & `violin.args.pos` arguments.

```{r rainclouds by time flip nudged}

ggplot(aging, aes(time, value, fill = time)) +
  geom_rain(alpha = .5, 
            boxplot.args.pos = list(
              width = 0.05, position = position_nudge(x = 0.13)),
            violin.args.pos = list(
              side = "r",
              width = 0.7, position = position_nudge(x = 0.2))) +
  theme_classic() +
  scale_fill_brewer(palette = 'Dark2') +
  coord_flip()
```

Instead of coloring the dots by time, lets see how our two groups are doing (old & young people).
We can do this by adding them as a covariate with the `cov` argument.

```{r rainclouds by time colored by group}

ggplot(aging, aes(time, value, fill = time)) +
  geom_rain(alpha = .3,
            cov = "group") +
  theme_classic() +
  scale_fill_brewer(palette = 'Dark2') +
  scale_color_manual(values=c("dodgerblue", "darkorange"))

```

These are distinct groups it would be much more informative to plot them separately!

```{r rainclouds by time by group}

ggplot(aging, aes(time, value, fill = group)) +
  geom_rain(alpha = .3) +
  theme_classic() +
  scale_fill_manual(values=c("dodgerblue", "darkorange"))

```

We can't really see the boxplots so lets dodge them while also nudging, we can do this with the boxplot position arg `boxplot.args.pos`. Remember to readd the defaults if you would like to keep them!

```{r rainclouds by time by group dodged}

ggplot(aging, aes(time, value, fill = group)) +
  geom_rain(alpha = .3, 
            boxplot.args.pos = list(
              position = ggpp::position_dodgenudge(x = .1), width = 0.05
            )) +
  theme_classic() +
  scale_fill_manual(values=c("dodgerblue", "darkorange"))
```

Lets flip them, while keeping the boxplots dodging.

```{r rainclouds by time by group dodged left}

ggplot(aging, aes(time, value, fill = group)) +
  geom_rain(alpha = .3, rain.side = 'l',
            boxplot.args.pos = list(
              position = ggpp::position_dodgenudge(x = .1), width = 0.05
            )) +
  theme_classic() +
  scale_fill_manual(values=c("dodgerblue", "darkorange"))
```

As you can see the `rain.side` arg negates the x position argument you give `geom_rain`.

Lets connect the individuals across time! 
We can do this with `id.long.var`

```{r rainclouds by time by group connected}

ggplot(aging, aes(time, value, fill = group)) +
  geom_rain(id.long.var = 'id',
            alpha = .3, rain.side = 'l',
            boxplot.args.pos = list(
              position = ggpp::position_dodgenudge(x = .1), width = 0.05
            )) +
  theme_classic() +
  scale_fill_manual(values=c("dodgerblue", "darkorange"))
```

We can make some aesthetic changes to make the violins and box plot's more visible. We will do this with `boxplot.args`, `violin.args`, `line.args` and `point.args`.

```{r rainclouds by time by group connected better}

ggplot(aging, aes(time, value, fill = group)) +
  geom_rain(id.long.var = 'id', rain.side = 'l',
            boxplot.args = list(alpha = .8, outlier.shape = NA),
            violin.args = list(alpha = .8, color = NA),
            point.args = list(alpha = .2),
            line.args = list(alpha = .05),
            boxplot.args.pos = list(
              position = ggpp::position_dodgenudge(x = .1), width = 0.05
            )) +
  theme_classic() +
  scale_fill_manual(values=c("dodgerblue", "darkorange"))
```

Let's color the dots by a covariate and use the viridis color palette!

```{r rainclouds by time by group connected better viridis cov}

ggplot(aging, aes(time, value, fill = group)) +
  geom_rain(cov = 'covariate', 
            id.long.var = 'id', rain.side = 'l',
            boxplot.args = list(alpha = .8, outlier.shape = NA),
            violin.args = list(alpha = .8, color = NA),
            point.args = list(alpha = .5),
            line.args = list(alpha = .05),
            boxplot.args.pos = list(
              position = ggpp::position_dodgenudge(x = .1), width = 0.05
            )) +
  theme_classic() +
  scale_fill_manual(values=c("dodgerblue", "darkorange")) +
  scale_color_viridis_c()
```

## Inference with flanking

Let's take a step back and look if the groups are significantly different in the first two time points!

```{r rainclouds aging two timepoints, echo = T, warning = T}

aging_subset <- aging[aging$time %in% c('t1', 't2'),]

ggplot(aging_subset, aes(time, value, fill = group)) +
  geom_rain(alpha = .5, rain.side = 'f', id.long.var = 'id') +
  theme_classic() +
  scale_fill_manual(values=c("dodgerblue", "darkorange"))
```

The last graph throws a warning since option `'f'` is being used with a `side` argument in `violin.args.pos` (default) which comes from `gghalves::geom_half_violin`. Yet, since we are flanking giving a `side` doesn't make sense. It defaults to a 2-by-2 flanking raincloud yet if you wish to not have the warning you can either give specific `violin.args.pos` or use the handy `rain.side = `'f2x2'`. There is alos a `'f1x1'` option if you would like default nudging for one-by-one flanking rainclouds.

```{r rainclouds aging two timepoints with f2x2}

ggplot(aging_subset, aes(time, value, fill = group)) +
  geom_rain(alpha = .5, rain.side = 'f2x2', id.long.var = 'id') +
  theme_classic() +
  scale_fill_manual(values=c("dodgerblue", "darkorange"))
```

We can color the lines & dots as well!

```{r rainclouds aging two timepoints dots and lines colored}

ggplot(aging_subset, aes(time, value, fill = group, color = group)) +
  geom_rain(alpha = .5, rain.side = 'f2x2', id.long.var = 'id') +
  theme_classic() +
  scale_fill_manual(values=c("dodgerblue", "darkorange")) +
  scale_color_manual(values=c("dodgerblue", "darkorange"))

```

#### Mean trend lines:
<br>
Here we add mean trend lines using stat_summary!

```{r rainclouds aging two timepoints inference}

ggplot(aging_subset, aes(time, value, fill = group)) +
  geom_rain(alpha = .5, rain.side = 'f') +
  theme_classic() +
  stat_summary(fun = mean, geom = "line", aes(group = group, color = group)) +
    stat_summary(fun = mean, geom = "point",
               aes(group = group, color = group)) +
    scale_fill_manual(values=c("dodgerblue", "darkorange")) +
    scale_colour_manual(values = c("dodgerblue", "darkorange"))

```

#### Significance testing:
<br>
Now we add a significance test between the two timepoints using the package ggsignif for young participants! In this case we could have used `rain.side = 'f1x1'` yet we use manual nudging.

```{r rainclouds aging two timepoints sig inference}

ggplot(aging_subset |> dplyr::filter(group == 'young'), aes(time, value, fill = time)) +
  geom_rain(alpha = .5, rain.side = 'f',
            boxplot.args.pos = list(width = .1, 
                                    position = position_nudge(x = c(-.13, .13))),
            violin.args.pos = list(width = .3, 
                                   position = position_nudge(x = c(rep(-.2, 256*2), rep(.2, 256*2))))) +
  geom_signif(
    comparisons = list(c("t1", "t2")),
    map_signif_level = TRUE) +
  scale_fill_manual(values=c("darkorange", "darkorange")) +
  theme_classic()

```

#### Advanced flanking
<br>
To do advanced flanking we need to supply positioning arguments for each element/group of the boxplot & violin. There are only `rain.side` defaults for 1-by-1 (i.e., `'f1x1'`) and 2-by-2 (i.e., `'f2x2'`) flanking rain clouds!

```{r rainclouds aging 4 timepoints inference}

ggplot(aging, aes(time, value, fill = group)) +
  geom_rain(alpha = .5, rain.side = 'f',
            boxplot.args.pos = list(width = .1,
             position = ggpp::position_dodgenudge(x = c(-.13, -.13, # t1 old, t1 young
                                                        -.13, -.13, 
                                                         .13, .13, # t3 old, t3 young
                                                         .13, .13))),
            violin.args.pos = list(width = .7,
             position = position_nudge(x = c(rep(-.2, 256*2), rep(-.2, 256*2),# t1
                                             rep(-.2, 256*2), rep(-.2, 256*2), # t2
                                             rep(.2, 256*2), rep(.2, 256*2),# t3
                                             rep(.2, 256*2), rep(.2, 256*2))))) +# t4
  theme_classic() +
  stat_summary(fun = median, geom = "line", aes(group = group, color = group)) +
    stat_summary(fun = median, geom = "point",
               aes(group = group, color = group)) +
    scale_fill_manual(values=c("dodgerblue", "darkorange")) +
    scale_colour_manual(values = c("dodgerblue", "darkorange"))

```


```{r rainclouds aging 4 timepoints inference with cov, echo = F, eval=F}

g1 <- ggplot(aging, aes(time, value, fill = group)) +
  geom_rain(alpha = .5, rain.side = 'f', cov = "covariate",
            boxplot.args.pos = list(width = .1,
                                     position = ggpp::position_dodgenudge(x = c(-.13, -.13, # t1 old, t1 young
                                                                                -.13, -.13, 
                                                                                .13, .13, # t3 old, t3 young
                                                                                .13, .13))),
            violin.args.pos = list(width = .7,
                                    position = position_nudge(x = c(rep(-.2, 256*2), rep(-.2, 256*2),# t1
                                                                    rep(-.2, 256*2), rep(-.2, 256*2), # t2
                                                                    rep(.2, 256*2), rep(.2, 256*2),# t3
                                                                    rep(.2, 256*2), rep(.2, 256*2))))) +# t4
  theme_classic() +
  scale_color_viridis_c() +
  scale_fill_manual(values=c("dodgerblue", "darkorange"))


g1 + stat_summary(data = aging, aes(time, value, group = group, color = group), fun = median, geom = "line", inherit.aes = FALSE)





  # stat_summary(data = aging, fun = median, geom = "line", aes(group = group, color = group)) +
  #   stat_summary(data = aging, fun = median, geom = "point",
  #              aes(group = group, color = group)) +
  #   scale_colour_manual(values = c("dodgerblue", "darkorange"))

```

Let's create a raincloudplot with `likert` data [IN PROGRESS]

```{r rainclouds , echo = F, eval=F}

#Create fake data
pre <- c(1,1,4,1,1,2,1,1,2,2,1,3,2,1,2,2,2,3,2,4,5,2,3,3,4,4,2,2,5,3,4,3,5,3,3,4,3,2,2,2,4,2,3,2,3,4,4,3,5,1,2,5,2,3,3,5,5,3,1,3,4,2,3,4,3,3,2,3,4,5,3,3,3,4,2,2,4,3,3,5,3,3,2,2,3,3,1,4,4,2,3,4,2,2,1,2,3,3,3,2,1,2,3,3,3,2,3,4,3,4,3,1,4,2,3,2,4,3,3,4,3,3,2,3,4,3,4,3,3,3)

post <- c(1,1,1,1,1,1,1,2,2,1,1,2,2,3,2,2,2,2,2,2,3,3,2,3,1,4,1,2,3,3,5,2,4,3,4,2,3,2,3,2,3,3,3,3,3,3,4,3,5,3,1,3,2,3,3,2,2,3,3,3,4,3,3,3,3,3,3,4,3,3,3,4,3,4,3,3,2,3,3,3,3,3,1,3,3,2,2,4,5,3,3,4,3,3,2,3,3,4,3,4,1,3,4,2,3,2,4,2,3,3,3,3,4,1,3,4,3,3,3,4,3,3,3,3,3,3,3,4,4,5)

likert_data = data.frame(pre,post)

likert_data$id <- as.factor(as.character(rep(1:dim(likert_data)[1])))
likert_data <- reshape2::melt(likert_data, id.vars = "id")
colnames(likert_data)[2] <- "time"
likert_data$covariate <- -likert_data$value*2

likert_data$group <- c(rep("old", 65), rep("young", 65), rep("old", 65), rep("young", 65))#,
                # rep("old", 65), rep("young", 200), rep("old", 200), rep("young", 200))

likert_data$value[likert_data$group == "young"] <- likert_data$value[likert_data$group == "young"] + 1
likert_data$value[likert_data$group == "old" & likert_data$time == "t2"] <- likert_data$value[likert_data$group == "old" & likert_data$time == "t2"] -2

likert_data$jit <- jitter(likert_data$value, amount = .2)


# Plot the object with `likert = TRUE`
f1 <- ggplot(likert_data, aes(time, value, fill = group, color = group)) +
  geom_rain(alpha = .5, rain.side = 'f', id.long.var = 'id', likert = T) +
  theme_classic() +
  scale_fill_manual(values=c("lightgrey", "grey")) +
  scale_colour_manual(values = c("lightgrey", "grey"))

f2 <- ggplot(likert_data) + 
 geom_bar(aes(x = time, fill = as.factor(value)), position = 'fill')+
  ylab('value')+
  xlab('time')+
  scale_y_continuous(position = 'right')+
  theme_classic()#+
  #coord_flip()

#install.packages("patchwork")
library(patchwork)

f3 <- f1 + f2
f3



proportions <- table(likert_data$pre)/length(likert_data$pre)

4*0.107 + 1 + 4*0.261

abs_range <- abs(min(likert_data$pre)) + abs(max(likert_data$pre))

4*0.107 + 1 + 4*0.261 + 4*.37 + 4*.18 + 4*.07 #(you don't need the last boundary)


bounds <- function(x, ...){
  
  l_unique_min1 <- length(unique(x))-1
  vec <- as.numeric(rep(0, l_unique_min1))
  proportions <- as.numeric(table(x)/length(x))

  s <- 0
  for (i in 1:l_unique_min1){
    vec[i] <- proportions[i]*l_unique_min1 + s
    s <- vec[i]
  }

  vec <- vec + min(x)
  
  return(vec)
}

m <- function(x, ...){
  m <- mean(x, na.rm = T)
  return(m)
}


ct <- reshape2::melt(likert_data)
library(ggridges)

ggplot(ct, aes(x = value, y = variable, fill = variable)) +
  geom_density_ridges(scale = .2,
    quantile_lines = T, quantile_fun = m) +
  geom_boxplot(width = .2, position = position_nudge(y = -.2))

ggplot(likert_data) +
  geom_density_ridges(
    aes(x = 1, y = pre),
    quantile_lines = T, quantile_fun = bounds)


ggplot(ct, aes(x = value, y = variable, fill = variable)) +
  geom_density_ridges(
    quantile_lines = T, quantile_fun = bounds) +
  geom_boxplot(width = .2, position = position_nudge(y= -.2)) +
 scale_x_continuous(limits=c(-15, 20))

ggplot(likert_data, aes(x=value, y=time, fill=time)) +
  geom_density_ridges(scale = .2,
    quantile_lines = T, quantile_fun = bounds) +
  geom_boxplot(width = .2, position = position_nudge(y= -.2)) +
  geom_point(aes(x=jit))

## see if gghalves can do quantile_fun

ggplot(ct, aes(x = value, y = variable, fill = variable)) +
  geom_violin(
    quantile_lines = T, quantile_fun = bounds) +
  geom_boxplot(width = .2, position = position_nudge(y= -.2)) +
 scale_x_continuous(limits=c(-15, 20))


#?stat_density_ridges


c <- ggplot(ct, aes(x = value, y = variable, fill = variable)) +
  geom_density_ridges(
    quantile_lines = T, quantile_fun = bounds) +
  geom_boxplot(width = .02, position = position_nudge(y= -.2)) +
  scale_x_continuous(limits=c(-15, 20)) 

# c + coord_flip()

 
```















